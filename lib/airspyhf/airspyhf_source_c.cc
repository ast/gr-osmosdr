/* -*- c++ -*- */
/*
 * Copyright 2013 Dimitri Stolnikov <horiz0n@gmx.net>
 *
 * GNU Radio is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3, or (at your option)
 * any later version.
 *
 * GNU Radio is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GNU Radio; see the file COPYING.  If not, write to
 * the Free Software Foundation, Inc., 51 Franklin Street,
 * Boston, MA 02110-1301, USA.
 */

/*
 * config.h is generated by configure.  It contains the results
 * of probing for features, options etc.  It should be the first
 * file included in your .cc file.
 */
#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include <stdexcept>
#include <iostream>
#include <string>
#include <algorithm>
#include <osmosdr/ranges.h>
#include <gnuradio/io_signature.h>

#include "airspyhf_source_c.h"
#include "arg_helpers.h"

#define MAX_DEVICES  32 // arbitrary number

airspyhf_source_c_sptr make_airspyhf_source_c (const std::string & args)
{
    return gnuradio::get_initial_sptr(new airspyhf_source_c (args));
}

/*
 * The private constructor
 */
airspyhf_source_c::airspyhf_source_c (const std::string &args)
: gr::sync_block ("airspyhf_source_c",
                  gr::io_signature::make(0, 0, 0),
                  gr::io_signature::make(1, 1, sizeof (gr_complex))),
_sample_rate(0),
_center_freq(0),
_freq_corr(0),
_dev(nullptr),
_lna_gain(0),
_att_gain(0),
_agc_on(true),
_stream_buff(nullptr)
{
    int ret;
    
    // TODO: open by serial
    dict_t dict = params_to_dict(args);
    
    _dev = NULL;
    ret = airspyhf_open(&_dev);
    if(ret != AIRSPYHF_SUCCESS) {
        throw std::runtime_error("airspyhf_open");
    }

    // At least this size in our work function
    _airspyhf_output_size = airspyhf_get_output_size(_dev);
    set_output_multiple(_airspyhf_output_size);
    
    uint32_t num_rates;
    airspyhf_get_samplerates(_dev, &num_rates, 0);
    _samplerates.resize(num_rates);
    // Get supported rates
    ret = airspyhf_get_samplerates(_dev, _samplerates.data(), num_rates);
    assert(ret == AIRSPYHF_SUCCESS);
    
    // airspyhf_lib_version
    // airspyhf_board_partid_serialno_read
    
    airspyhf_set_lib_dsp(_dev, true);
    airspyhf_set_hf_agc(_dev, _agc_on);
    airspyhf_set_hf_agc_threshold(_dev, 1); // 1 = high
    
    set_center_freq(14e6);
    set_sample_rate(768e3);
}

/*
 * Our virtual destructor.
 */
airspyhf_source_c::~airspyhf_source_c ()
{
    airspyhf_close(_dev);
}

// C trampoline function
int airspyhf_source_c::_airspyhf_rx_callback(airspyhf_transfer_t *transfer)
{
    airspyhf_source_c *obj = (airspyhf_source_c *)transfer->ctx;
    return obj->airspyhf_rx_callback(transfer);
}

int airspyhf_source_c::airspyhf_rx_callback(airspyhf_transfer_t *t)
{
    std::unique_lock<std::mutex> lock(_stream_mutex);
    while (_stream_buff == nullptr) _stream_cond.wait(lock);
    //_dropped_samples = t->dropped_samples;
    if (t->dropped_samples) {
        // TODO: fix logging
    }
    // Copy to _stream_buff
    std::memcpy(_stream_buff, t->samples, sizeof(gr_complex) * _airspyhf_output_size);
    
    _stream_buff = nullptr;
    _callback_done_cond.notify_one();
    
    return 0;
}

bool airspyhf_source_c::start()
{
    if (!_dev) {
        return false;
    }
    int ret = airspyhf_start(_dev, _airspyhf_rx_callback, (void *)this);
    assert(ret == AIRSPYHF_SUCCESS);
    return true;
}

bool airspyhf_source_c::stop()
{
    if (!_dev) {
        return false;
    }
    int ret = airspyhf_stop(_dev);
    assert(ret == AIRSPYHF_SUCCESS);
    return true;
}

int airspyhf_source_c::work(int noutput_items,
                            gr_vector_const_void_star &input_items,
                            gr_vector_void_star &output_items )
{
    assert(noutput_items >= _airspyhf_output_size);
    
    if (!airspyhf_is_streaming(_dev)) {
        // TODO: check error
        return -1;
    }
    
    std::unique_lock<std::mutex> lock(_stream_mutex);
    _stream_buff = output_items[0];
    //_dropped_samples = 0;
    // Notify callback that the buffer is ready for samples
    _stream_cond.notify_one();
    // Wait for callback to write samples to buffer
    while (_stream_buff != nullptr) _callback_done_cond.wait(lock);

    return _airspyhf_output_size;
}

std::vector<std::string> airspyhf_source_c::get_devices()
{
    std::vector<std::string> devices;
    std::string label;
    
    std::vector<uint64_t> serials(MAX_DEVICES);
    int count = airspyhf_list_devices(serials.data(), MAX_DEVICES);
    serials.resize(count);
    
    for(std::vector<uint64_t>::size_type i = 0; i != serials.size(); i++) {
        std::stringstream args;
        args << "airspyhf=" << i << ",";
        args << "label='AirspyHF'" << ",";
        args << "serial=" << std::hex << serials[i];
        devices.push_back(args.str());
        
        std::cout << args.str() << std::endl;
    }
    
    return devices;
}

size_t airspyhf_source_c::get_num_channels()
{
    // This is fixed
    return 1;
}

osmosdr::meta_range_t airspyhf_source_c::get_sample_rates()
{
    osmosdr::meta_range_t range;
    
    for (size_t i = 0; i < _samplerates.size(); i++) {
        range.push_back(osmosdr::range_t(_samplerates[i]));
    }
    
    return range;
}

double airspyhf_source_c::set_sample_rate( double rate )
{
    int ret;
    ret = airspyhf_set_samplerate(_dev, (uint32_t) rate);
    if (ret == AIRSPYHF_SUCCESS) {
        _sample_rate = rate;
    }
    return _sample_rate;
}

double airspyhf_source_c::get_sample_rate()
{
    return _sample_rate;
}

osmosdr::freq_range_t airspyhf_source_c::get_freq_range( size_t chan )
{
    return osmosdr::freq_range_t(9e3, 260.0e6);
}

double airspyhf_source_c::set_center_freq(double freq, size_t chan)
{
    int ret;
    assert(_dev != nullptr);
    ret = airspyhf_set_freq(_dev, freq);
    if (ret == AIRSPYHF_SUCCESS) {
        _center_freq = freq;
    }
    
    return _center_freq;
}

double airspyhf_source_c::get_center_freq( size_t chan )
{
    return _center_freq;
}

double airspyhf_source_c::set_freq_corr(double ppm, size_t chan )
{
    int ret;
    int32_t ppb = (int32_t)(ppm * 1.0e3);
    assert(_dev != nullptr);
    
    ret = airspyhf_set_calibration(_dev, ppb);
    if (ret == AIRSPYHF_SUCCESS) {
        _freq_corr = ppm;
    }
    
    return ppm;
}

double airspyhf_source_c::get_freq_corr(size_t chan)
{
    int ret;
    int32_t ppb = 0;
    assert(chan == 0);
    ret = airspyhf_get_calibration(_dev, &ppb);
    assert(ret == AIRSPYHF_SUCCESS);
    return ppb / 1.0e3;
}

std::vector<std::string> airspyhf_source_c::get_gain_names(size_t chan)
{
    assert(chan == 0);
    std::vector<std::string> gains;
    gains.push_back("ATT");
    gains.push_back("LNA");
    return gains;
}

osmosdr::gain_range_t airspyhf_source_c::get_gain_range(size_t chan)
{
    return get_gain_range("ATT", chan);
}

osmosdr::gain_range_t airspyhf_source_c::get_gain_range(const std::string &name, size_t chan)
{
    assert(chan == 0);
    
    // TODO: enable AGC somewhere
    
    if (name == "ATT") {
        // Possible values: 0..8 Range: 0..48 dB Attenuation with 6 dB steps
        return osmosdr::gain_range_t(-48.0,0,6);
    }
    if (name == "LNA") {
        // 0 or 1: 1 to activate LNA (alias PreAmp): 1 = +6 dB gain - compensated in digital
        return osmosdr::gain_range_t(0,6,6);
    }
    
    return osmosdr::gain_range_t();
}


double airspyhf_source_c::set_gain(double gain, size_t chan)
{
    assert(chan == 0);
    return set_gain(gain, "ATT", chan);
}

double airspyhf_source_c::set_gain(double gain, const std::string & name, size_t chan)
{
    int ret;
    assert(chan == 0);
    
    // TODO: avoid multiple sets
    
    if (name == "ATT") {
        // Possible values: 0..8 Range: 0..48 dB Attenuation with 6 dB steps
        uint8_t att = -gain/6.0;
        ret = airspyhf_set_hf_att(_dev, att);
        printf("set att: %d\n", att);
        assert(ret == AIRSPYHF_SUCCESS);
        _att_gain = -6.0 * att;
        return  _att_gain;
    }
    if (name == "LNA") {
        // 0 or 1: 1 to activate LNA (alias PreAmp): 1 = +6 dB gain - compensated in digital
        uint8_t flag = gain >= 3.0 ? 1 : 0;
        ret = airspyhf_set_hf_lna(_dev, flag);
        printf("set lns: %d\n", flag);
        assert(ret == AIRSPYHF_SUCCESS);
        _lna_gain = 6.0 * flag;
        return _lna_gain;
    }

    return 0.0;
}

double airspyhf_source_c::get_gain(size_t chan)
{
    assert(chan == 0);
    return get_gain("ATT", chan);
    
}

double airspyhf_source_c::get_gain(const std::string &name, size_t chan)
{
    assert(chan == 0);
    
    if (name == "ATT") {
        return _att_gain;
    }
    if (name == "LNA") {
        return _lna_gain;
    }
    
    return 0.0;
}

bool airspyhf_source_c::set_gain_mode(bool automatic, size_t chan) {
    assert(chan == 0);
    int ret;
    assert(_dev != nullptr);
    ret = airspyhf_set_hf_agc(_dev, automatic);
    printf("set_gain_mode\n");
    if (ret == AIRSPYHF_SUCCESS) {
        _agc_on = automatic;
    }
    
    return _agc_on;
}

bool airspyhf_source_c::get_gain_mode(size_t chan) {
    assert(chan == 0);
    return _agc_on;
}

void airspyhf_source_c::set_iq_balance(const std::complex<double> &balance, size_t chan) {
    int ret;
    float w = std::arg(balance);
    ret = airspyhf_set_optimal_iq_correction_point(_dev, w);
    assert(ret == AIRSPYHF_SUCCESS);
}

std::vector< std::string > airspyhf_source_c::get_antennas(size_t chan)
{
    assert(chan == 0);
    
    std::vector<std::string> antennas;
    antennas.push_back(get_antenna(chan));
    return antennas;
}

std::string airspyhf_source_c::set_antenna(const std::string & antenna, size_t chan)
{
    assert(chan == 0);
    return get_antenna(chan);
}

std::string airspyhf_source_c::get_antenna(size_t chan)
{
    // TODO: is this configureable?
    return "RX";
}
